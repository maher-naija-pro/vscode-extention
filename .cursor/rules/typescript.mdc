# TypeScript Best Practices for VS Code Extensions

## Overview
This rule ensures TypeScript code follows best practices for VS Code extension development, focusing on type safety, maintainability, and performance.

## Type Safety & Configuration

### 1. TypeScript Configuration
- Enable strict mode in `tsconfig.json`
- Use ES2020 target for modern VS Code compatibility
- Enable source maps for debugging
- Set `skipLibCheck: true` for better performance

### 2. Strict Type Checking
```typescript
// ✅ Good: Explicit types
function processDocument(document: vscode.TextDocument): Promise<string> {
    return Promise.resolve(document.getText());
}

// ❌ Bad: Implicit any
function processDocument(document) {
    return Promise.resolve(document.getText());
}
```

### 3. Interface Design
```typescript
// ✅ Good: Specific, focused interfaces
interface ExtensionConfig {
    readonly enabled: boolean;
    readonly timeout: number;
    readonly logLevel: 'debug' | 'info' | 'warn' | 'error';
}

// ❌ Bad: Overly broad interface
interface ExtensionConfig {
    [key: string]: any;
}
```

## VS Code API Types

### 4. Proper VS Code Type Usage
```typescript
// ✅ Good: Use VS Code types
import * as vscode from 'vscode';

class DocumentProvider implements vscode.TextDocumentContentProvider {
    provideTextDocumentContent(uri: vscode.Uri): string {
        return this.generateContent(uri);
    }
}

// ❌ Bad: Avoid generic types for VS Code objects
function processEditor(editor: any): void {
    // This loses type safety
}
```

### 5. Event Handler Types
```typescript
// ✅ Good: Proper event handler typing
const disposable = vscode.workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent) => {
    const { document, contentChanges } = event;
    // Type-safe access to document and changes
});

// ❌ Bad: Untyped event handlers
const disposable = vscode.workspace.onDidChangeTextDocument((event) => {
    // No type safety
});
```

## Generic Usage

### 6. Generic Functions and Classes
```typescript
// ✅ Good: Generic utility functions
function createDisposable<T extends vscode.Disposable>(item: T): T {
    return item;
}

// ✅ Good: Generic data structures
class Cache<T> {
    private items = new Map<string, T>();
    
    set(key: string, value: T): void {
        this.items.set(key, value);
    }
    
    get(key: string): T | undefined {
        return this.items.get(key);
    }
}
```

### 7. Constraint Bounds
```typescript
// ✅ Good: Constrained generics
function processText<T extends vscode.TextDocument>(document: T): string {
    return document.getText();
}

// ✅ Good: Multiple constraints
function processDocument<T extends vscode.TextDocument & { languageId: string }>(
    document: T
): string {
    return `${document.languageId}: ${document.getText()}`;
}
```

## Error Handling & Types

### 8. Error Types
```typescript
// ✅ Good: Custom error classes
class ExtensionError extends Error {
    constructor(
        message: string,
        public readonly code: string,
        public readonly details?: unknown
    ) {
        super(message);
        this.name = 'ExtensionError';
    }
}

// ✅ Good: Typed error handling
async function safeOperation<T>(operation: () => Promise<T>): Promise<T | ExtensionError> {
    try {
        return await operation();
    } catch (error) {
        return new ExtensionError(
            error instanceof Error ? error.message : 'Unknown error',
            'OPERATION_FAILED',
            error
        );
    }
}
```

### 9. Result Types
```typescript
// ✅ Good: Result pattern for operations
type Result<T, E = Error> = 
    | { success: true; data: T }
    | { success: false; error: E };

async function processFile(uri: vscode.Uri): Promise<Result<string, ExtensionError>> {
    try {
        const content = await vscode.workspace.fs.readFile(uri);
        return { success: true, data: content.toString() };
    } catch (error) {
        return { 
            success: false, 
            error: new ExtensionError('Failed to read file', 'FILE_READ_ERROR', error) 
        };
    }
}
```

## Async/Await Patterns

### 10. Promise Handling
```typescript
// ✅ Good: Proper async/await with error handling
async function activateExtension(context: vscode.ExtensionContext): Promise<void> {
    try {
        const config = await loadConfiguration();
        await initializeServices(config);
        
        // Register commands
        const disposable = vscode.commands.registerCommand('extension.command', async () => {
            try {
                await executeCommand();
            } catch (error) {
                vscode.window.showErrorMessage(`Command failed: ${error.message}`);
            }
        });
        
        context.subscriptions.push(disposable);
    } catch (error) {
        vscode.window.showErrorMessage(`Extension activation failed: ${error.message}`);
        throw error;
    }
}

// ❌ Bad: Unhandled promises
function activateExtension(context: vscode.ExtensionContext): void {
    loadConfiguration().then(config => {
        // Missing error handling
    });
}
```

### 11. Cancellation Support
```typescript
// ✅ Good: Cancellation token support
async function longRunningOperation(
    token: vscode.CancellationToken
): Promise<string> {
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            resolve('Operation completed');
        }, 5000);
        
        token.onCancellationRequested(() => {
            clearTimeout(timeout);
            reject(new Error('Operation cancelled'));
        });
    });
}
```

## Performance & Memory

### 12. Lazy Loading
```typescript
// ✅ Good: Lazy initialization
class ExtensionService {
    private _heavyService: HeavyService | undefined;
    
    get heavyService(): HeavyService {
        if (!this._heavyService) {
            this._heavyService = new HeavyService();
        }
        return this._heavyService;
    }
}

// ✅ Good: Lazy command registration
export function activate(context: vscode.ExtensionContext): void {
    // Register lightweight commands immediately
    registerBasicCommands(context);
    
    // Register heavy commands on first use
    const heavyCommand = vscode.commands.registerCommand('extension.heavy', () => {
        // Lazy load heavy functionality
        import('./heavyModule').then(module => {
            module.executeHeavyOperation();
        });
    });
    
    context.subscriptions.push(heavyCommand);
}
```

### 13. Resource Management
```typescript
// ✅ Good: Proper disposal pattern
class ResourceManager {
    private disposables = new vscode.DisposableStore();
    
    constructor() {
        this.disposables.add(
            vscode.workspace.onDidChangeTextDocument(this.handleDocumentChange.bind(this))
        );
    }
    
    dispose(): void {
        this.disposables.dispose();
    }
    
    private handleDocumentChange(event: vscode.TextDocumentChangeEvent): void {
        // Implementation
    }
}
```

## Code Organization

### 14. Module Structure
```typescript
// ✅ Good: Clear module exports
// commands/index.ts
export { registerCommands } from './commandRegistry';
export { CommandHandler } from './types';

// ✅ Good: Barrel exports
// index.ts
export * from './commands';
export * from './providers';
export * from './services';
export * from './types';
```

### 15. Type Definitions
```typescript
// ✅ Good: Centralized type definitions
// types/index.ts
export interface ExtensionState {
    isActive: boolean;
    lastActivation: Date;
    configuration: ExtensionConfig;
}

export type CommandResult = 'success' | 'failure' | 'cancelled';

export interface CommandContext {
    document?: vscode.TextDocument;
    selection?: vscode.Selection;
    uri?: vscode.Uri;
}
```

## Best Practices Summary

1. **Always use explicit types** for function parameters and return values
2. **Leverage VS Code's built-in types** from `@types/vscode`
3. **Use generics** for reusable, type-safe code
4. **Implement proper error handling** with typed errors
5. **Support cancellation** for long-running operations
6. **Use lazy loading** for performance optimization
7. **Properly dispose resources** to prevent memory leaks
8. **Organize types centrally** for better maintainability
9. **Enable strict mode** in TypeScript configuration
10. **Use async/await** consistently for asynchronous operations

Remember: Type safety in VS Code extensions not only prevents runtime errors but also provides better IntelliSense and developer experience.
description:
globs:
alwaysApply: true
---
