# VS Code Extension Development Best Practices

## Project Structure & Organization

### 1. File Organization
- Keep source code in `src/` directory
- Separate concerns: commands, providers, webviews in different modules
- Use consistent naming conventions (PascalCase for classes, camelCase for functions)
- Organize by feature, not by type

### 2. Package.json Configuration
- Always specify `engines.vscode` with minimum version
- Use semantic versioning for `version` field
- Provide clear `displayName` and `description`
- Categorize with `categories` array
- Set appropriate `activationEvents` (prefer `onCommand` over `*`)

### 3. TypeScript Best Practices
- Enable strict mode in `tsconfig.json`
- Use proper type annotations for all functions
- Leverage VS Code API types from `@types/vscode`
- Avoid `any` type - use proper interfaces

## Extension Architecture

### 4. Activation & Lifecycle
- Implement `activate()` function efficiently
- Use lazy loading for heavy operations
- Properly dispose resources in `deactivate()`
- Register disposables with `context.subscriptions.push()`

### 5. Command Registration
- Register commands in `package.json` commands array
- Use descriptive command IDs with extension prefix
- Implement command handlers in separate functions
- Handle errors gracefully with try-catch blocks

### 6. Event Handling
- Use appropriate event listeners (onDidChangeTextDocument, onDidChangeActiveTextEditor)
- Unsubscribe from events when disposing
- Debounce frequent events to avoid performance issues

## Performance & Memory Management

### 7. Resource Management
- Always dispose of disposables
- Use `DisposableStore` for managing multiple disposables
- Avoid memory leaks from event listeners
- Clean up file watchers and timers

### 8. Async Operations
- Use `async/await` for better error handling
- Implement proper cancellation with `CancellationToken`
- Show progress indicators for long-running operations
- Handle timeouts appropriately

### 9. File System Operations
- Use VS Code's built-in file system APIs
- Handle file permissions and access errors
- Implement proper error handling for file operations
- Use relative paths when possible

## User Experience

### 10. Error Handling
- Provide meaningful error messages
- Use `vscode.window.showErrorMessage()` for user-facing errors
- Log detailed errors for debugging
- Implement graceful degradation

### 11. Progress & Feedback
- Show progress for long operations
- Use `vscode.window.withProgress()` for background tasks
- Provide status bar information when relevant
- Use notifications sparingly

### 12. Configuration
- Provide sensible defaults for all settings
- Use `contributes.configuration` in package.json
- Validate configuration values
- Support workspace and user-level settings

## Testing & Quality

### 13. Testing Strategy
- Write unit tests for core logic
- Use VS Code's extension testing framework
- Test activation/deactivation scenarios
- Mock VS Code API for isolated testing

### 14. Error Logging
- Use `console.log()` for development
- Implement proper logging levels
- Log errors with context information
- Use VS Code's output channel for extension logs

### 15. Code Quality
- Follow ESLint rules
- Use Prettier for consistent formatting
- Implement proper JSDoc comments
- Maintain consistent code style

## Security & Best Practices

### 16. Security Considerations
- Validate all user inputs
- Sanitize file paths and URIs
- Use HTTPS for external requests
- Implement proper authentication when needed

### 17. Extension Marketplace
- Write clear README with usage examples
- Provide screenshots and GIFs
- Include changelog
- Test extension thoroughly before publishing

### 18. Performance Monitoring
- Monitor extension activation time
- Profile memory usage
- Test with large files/workspaces
- Optimize hot paths

## Common Patterns

### 19. Command Pattern
```typescript
export function activate(context: vscode.ExtensionContext) {
    const disposable = vscode.commands.registerCommand('extension.commandName', async () => {
        try {
            // Command implementation
        } catch (error) {
            vscode.window.showErrorMessage(`Error: ${error.message}`);
        }
    });
    context.subscriptions.push(disposable);
}
```

### 20. Provider Pattern
```typescript
class MyProvider implements vscode.TextDocumentContentProvider {
    provideTextDocumentContent(uri: vscode.Uri): string {
        // Implementation
        return content;
    }
}
```

### 21. Webview Pattern
```typescript
const panel = vscode.window.createWebviewPanel(
    'myWebview',
    'My Webview',
    vscode.ViewColumn.One,
    {
        enableScripts: true,
        retainContextWhenHidden: true
    }
);
```

## Debugging Tips

### 22. Development Setup
- Use `F5` to launch extension in new window
- Set breakpoints in extension code
- Use `console.log()` for debugging
- Check Developer Tools console

### 23. Common Issues
- Extension not activating: check activation events
- Commands not working: verify registration
- Performance issues: profile with DevTools
- Memory leaks: check disposables

## Resources & References

### 24. Official Documentation
- [VS Code Extension API](https://code.visualstudio.com/api)
- [Extension Samples](https://github.com/microsoft/vscode-extension-samples)
- [Extension Marketplace Guidelines](https://code.visualstudio.com/docs/extensions/publish/package)

### 25. Community Resources
- VS Code Extension Community Discord
- Stack Overflow with `vscode-extension` tag
- GitHub discussions in vscode repository

Remember: Always test your extension thoroughly, handle errors gracefully, and prioritize user experience over complex features.
description:
globs:
alwaysApply: true
---
